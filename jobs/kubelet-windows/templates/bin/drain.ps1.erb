trap { $host.SetShouldExit(1) }
$ErrorActionPreference = "Stop";
$OutLog = "C:\var\vcap\sys\log\kubelet-windows\drain.stdout.log"
$ErrLog = "C:\var\vcap\sys\log\kubelet-windows\drain.stderr.log"

function Log-Out ($message) {
  $message | Out-File -Append -Encoding ASCII $OutLog
}

function Log-Err ($message) {
  $message | Out-File -Append -Encoding ASCII $ErrLog
}

function main {
  if (kubelet_is_running) {
    Retry-Command $function:drain_kubelet drain_kubelet
    # watch_disks TODO(BM/LH): implement this?
    Retry-Command $function:delete_drained_node delete_drained_node
  }

  echo "0"
}

function drain_kubelet() {
  Try {
    $ErrorActionPreference = "Stop";
    $nodes=(/var/vcap/packages/kubernetes-windows/bin/kubectl `
    --kubeconfig /var/vcap/jobs/kubelet-windows/config/kubeconfig-drain `
    get nodes -o json | ConvertFrom-Json).Items
    Log-Out (/var/vcap/packages/kubernetes-windows/bin/kubectl `
      --kubeconfig /var/vcap/jobs/kubelet-windows/config/kubeconfig-drain `
      get nodes -o wide)

    $node_name=($nodes | ? { $_.metadata.labels."bosh.id" -eq "<%= spec.id %>" }).metadata.name

    if (!$node_name) {
      Log-Out "Node name is empty"
      return
    }
    /var/vcap/packages/kubernetes-windows/bin/kubectl `
      --kubeconfig /var/vcap/jobs/kubelet-windows/config/kubeconfig-drain drain "${node_name}" `
      --grace-period 10 --force --delete-local-data --ignore-daemonsets | Out-File -Append -Encoding ASCII $OutLog
    return
  } Catch [System.Exception] {
    Log-Err $_.Exception.Message
    Log-Err $_.InvocationInfo.PositionMessage
    Log-Err $_.ScriptStackTrace
    Write-Error "Exception"
  }
}

function delete_drained_node() {
  Try {
    $ErrorActionPreference = "Stop";
    $nodes=(/var/vcap/packages/kubernetes-windows/bin/kubectl `
      --kubeconfig /var/vcap/jobs/kubelet-windows/config/kubeconfig-drain `
      get nodes -o json | ConvertFrom-Json).Items
    Log-Out (/var/vcap/packages/kubernetes-windows/bin/kubectl `
      --kubeconfig /var/vcap/jobs/kubelet-windows/config/kubeconfig-drain `
      get nodes -o wide)

    $node_name=($nodes | ? { $_.metadata.labels."bosh.id" -eq "<%= spec.id %>" }).metadata.name

    if (!$node_name) {
      Log-Out "Node name is empty"
      return
    }
    /var/vcap/packages/kubernetes-windows/bin/kubectl `
      --kubeconfig /var/vcap/jobs/kubelet-windows/config/kubeconfig-drain delete node "${node_name}" `
      --ignore-not-found | Out-File -Append -Encoding ASCII $OutLog
    return
  } Catch {
    Log-Err $_.Exception.Message
    Log-Err $_.InvocationInfo.PositionMessage
    Log-Err $_.ScriptStackTrace
    Write-Error "Exception"
  }
}

function Retry-Command {
  [CmdletBinding()]
  Param(
    [Parameter(Position=0, Mandatory=$true)]
    [scriptblock]$ScriptBlock,

    [Parameter(Position=1, Mandatory=$true)]
    [string]$CommandName,

    [Parameter(Position=2, Mandatory=$false)]
    [int]$Maximum = 4,

    [Parameter(Position=3, Mandatory=$false)]
    [int]$Delay = 5000
  )

  Begin {
      $cnt = 0
  }

  Process {
    Log-Out ("[{0}] run {1}" -f (get-date -Format "yyyy-MM-ddTHH:mm:ssZ"), $CommandName)
    do {
      $cnt++
      try {
        $ScriptBlock.Invoke()
        return
      } Catch {
          Log-Err ("[{0}] Unsuccessful {1}, retrying attempt {2} out of {3}" -f (get-date -Format "yyyy-MM-ddTHH:mm:ssZ"), $CommandName, $cnt, $Maximum)
          Start-Sleep -Milliseconds $Delay
      }
    } while ($cnt -lt $Maximum)

    # Throw an error after $Maximum unsuccessful invocations. Doesn't need
    # a condition, since the function returns upon successful invocation.
    Log-Err ("[{0}] run {1}`n" -f (get-date -Format "yyyy-MM-ddTHH:mm:ssZ"), "$CommandName Execution failed.")
    throw "$CommandName Execution failed."
  }
}

function kubelet_is_running() {
  curl.exe --silent --fail http://localhost:10248/healthz
  return $?
}

main
